from synch import Lock, acquire, release, wait, Condition, notify, notifyAll
from alloc import malloc, free

def Bdeque(n) returns initial:
    '''
    returns the initial value of an empty deque
    '''
    initial = { 
        .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
        .p_cond: Condition(), .g_cond: Condition(), .lock: Lock()
    }
# put_condition = wait for it to be not full! not_full
# get_condition = wait for it to be not empty! not_empty 

def put_left(d, v):
    '''
    d points to a deque and v is some value. 
    Put v at the right-end of the deque. 
    '''
    acquire(?d->lock)
    if d->count == d->size:
        wait(?d->p_cond, ?d->lock)
    d->data[d->head] = v 
    d->head = (d->head % d->size) + 1 
    d->count += 1
    # notify all that it is no longer empty (if count is now 1) 
    if d->count == 1:
        notifyAll(?d->g_cond) 
    # only notify put_condition (not full) 
    
    notify(?d->p_cond) 
    
    release(?d->lock)

def put_right(d, v):
    '''
    d points to a deque and v is some value. 
    Put v at the left-end of the deque. 
    '''
    let node = malloc({ .value: v, .next: None, .prev: None}):
        acquire(?d->lock)
        let prev = d->tail->prev:
            node->prev = prev
            node->next = d->tail
            d->tail->prev = node
            prev->next = node
        d->len += 1
        release(?d->lock)
    
def get_left(d) returns result:
    '''
    d points to a deque. 
    If deque is empty, the operation should return None. 
    Otherwise, it should remove and return the value at the left-end of the deque. 
    '''
    acquire(?d->lock)
    let head = d->head->next:
        if d->len != 0:
            result = head->value
            d->head->next = head->next
            d->head->next->prev = d->head
            d->len -= 1
            free(head)
        else:
            result = None 
    release(?d->lock)

def get_right(d) returns result:
    '''
    d points to a deque. 
    If deque is empty, the operation should return None. 
    Otherwise, it should remove and return the value at the right-end of the deque. 
    '''
    acquire(?d->lock)
    let tail = d->tail->prev:
        if d->len != 0:
            result = tail->value
            d->tail->prev = tail->prev
            d->tail->prev->next = d->tail
            d->len -= 1
            free(tail)
        else:
            result = None
    release(?d->lock)