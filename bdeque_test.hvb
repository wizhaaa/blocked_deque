Issue: Behavior violation: unexpected output

Modules:
  alloc: /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/harmony_model_checker/modules/alloc.hny
  bag: /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/harmony_model_checker/modules/bag.hny
  __main__: bdeque_test.hny
  synch: /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/harmony_model_checker/modules/synch.hny
  bdeque: bdeque_impl.hny
  list: /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/harmony_model_checker/modules/list.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=1 column=1
  end statement:     line=56 column=10
  source code:       import bdeque
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 54
  explanation:       jump over method definition: set program counter to 54
  module:            list
  start statement:   line=2 column=1
  end statement:     line=2 column=35
  source code:       def subseq(s, b, e) returns result:
                     ^^^

Step 3:
  program counter:   54
  hvm code:          Push PC(57)
  explanation:       push constant PC(57)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(57)]

Step 4:
  program counter:   55
  hvm code:          Builtin(list$tail)
  explanation:       pop pc () and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   56
  hvm code:          Jump 602
  explanation:       jump over method definition: set program counter to 602
  start statement:   line=12 column=1
  end statement:     line=12 column=27
  source code:       def tail(s) returns result:
                     ^^^

Step 6:
  program counter:   602
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  module:            bag
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(605)]

Step 7:
  program counter:   603
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc () and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   604
  hvm code:          Jump 624
  explanation:       jump over method definition: set program counter to 624
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^

Step 9:
  program counter:   624
  hvm code:          Push PC(627)
  explanation:       push constant PC(627)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(627)]

Step 10:
  program counter:   625
  hvm code:          Builtin(bag$size)
  explanation:       pop pc () and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   626
  hvm code:          Jump 646
  explanation:       jump over method definition: set program counter to 646
  start statement:   line=23 column=1
  end statement:     line=23 column=27
  source code:       def size(bg) returns count:
                     ^^^

Step 12:
  program counter:   646
  hvm code:          Push PC(649)
  explanation:       push constant PC(649)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(649)]

Step 13:
  program counter:   647
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc () and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   648
  hvm code:          Jump 665
  explanation:       jump over method definition: set program counter to 665
  start statement:   line=29 column=1
  end statement:     line=29 column=27
  source code:       def bmin(bg) returns count:
                     ^^^

Step 15:
  program counter:   665
  hvm code:          Push PC(668)
  explanation:       push constant PC(668)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(668)]

Step 16:
  program counter:   666
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc () and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   667
  hvm code:          Jump 693
  explanation:       jump over method definition: set program counter to 693
  start statement:   line=34 column=1
  end statement:     line=34 column=27
  source code:       def bmax(bg) returns count:
                     ^^^

Step 18:
  program counter:   693
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(696)]

Step 19:
  program counter:   694
  hvm code:          Builtin(bag$add)
  explanation:       pop pc () and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   695
  hvm code:          Jump 722
  explanation:       jump over method definition: set program counter to 722
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^

Step 21:
  program counter:   722
  hvm code:          Push PC(725)
  explanation:       push constant PC(725)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(725)]

Step 22:
  program counter:   723
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc () and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   724
  hvm code:          Jump 1205
  explanation:       jump over method definition: set program counter to 1205
  start statement:   line=50 column=1
  end statement:     line=50 column=35
  source code:       def remove(bg, elt) returns result:
                     ^^^

Step 24:
  program counter:   1205
  hvm code:          Push {:}
  explanation:       push constant {:}
  module:            alloc
  start statement:   line=1 column=1
  end statement:     line=1 column=10
  source code:       pool = {:}
                            ^^^
  stack:             [{:}, {:}]

Step 25:
  program counter:   1206
  hvm code:          Store alloc$pool
  explanation:       pop value ({:}) and store into variable alloc$pool
  source code:       pool = {:}
                     ^^^^^^
  shared variables:  { alloc$pool: {:} }
  stack:             [{:}]

Step 26:
  program counter:   1207
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=2 column=1
  end statement:     line=2 column=8
  source code:       next = 0
                            ^
  stack:             [{:}, 0]

Step 27:
  program counter:   1208
  hvm code:          Store alloc$next
  explanation:       pop value (0) and store into variable alloc$next
  source code:       next = 0
                     ^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:} }
  stack:             [{:}]

Step 28:
  program counter:   1209
  hvm code:          Jump 1723
  explanation:       jump over method definition: set program counter to 1723
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^

Step 29:
  program counter:   1723
  hvm code:          Push PC(1250)
  explanation:       push program counter constant 1250 ()
  module:            __main__
  start statement:   line=10 column=1
  end statement:     line=10 column=23
  source code:       d = bdeque.Bdeque(SIZE)
                         ^^^^^^^^^^^^^
  stack:             [{:}, PC(1250)]

Step 30:
  program counter:   1724
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       d = bdeque.Bdeque(SIZE)
                                       ^^^^
  stack:             [{:}, PC(1250), 2]

Step 31:
  program counter:   1725
  hvm code:          2-ary Closure
  explanation:       pop 2 values (2, PC(1250)); push result (?PC(1250)[2])
  source code:       d = bdeque.Bdeque(SIZE)
                         ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1250)[2]]

Step 32:
  program counter:   1726
  hvm code:          Load
  explanation:       pop an argument (2) and call method (1250: "Bdeque")
  start expression:  line=10 column=5
  end expression:    line=10 column=23
  call trace:        __init__() --> Bdeque(2)
  stack:             [{:}, [], 27618, 2]

Step 33:
  program counter:   1250
  hvm code:          Frame Bdeque(n)
  explanation:       pop argument (2), assign to n, and run method "Bdeque"
  module:            bdeque
  start statement:   line=4 column=1
  end statement:     line=4 column=30
  source code:       def Bdeque(n) returns initial:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { n: 2 }
  stack:             [{:}, [], 27618, {:}]

Step 34:
  program counter:   1251
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=8 column=5
  end statement:     line=11 column=5
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, {:}]

Step 35:
  program counter:   1252
  hvm code:          Push "data"
  explanation:       push constant "data"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, {:}, "data"]

Step 36:
  program counter:   1253
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, {:}, "data", []]

Step 37:
  program counter:   1254
  hvm code:          Push None
  explanation:       push constant None
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, {:}, "data", [], None]

Step 38:
  program counter:   1255
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (None, []); insert first value into the second; push result ([None])
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, {:}, "data", [ None ]]

Step 39:
  program counter:   1256
  hvm code:          LoadVar n
  explanation:       push value (2) of variable "n"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, {:}, "data", [ None ], 2]

Step 40:
  program counter:   1257
  hvm code:          2-ary *
  explanation:       pop 2 values (2, [None]); create multiple copies of list; push result ([None, None])
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, {:}, "data", [ None, None ]]

Step 41:
  program counter:   1258
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([None, None], "data", {:}); add key/value pair to dictionary; push result ({ "data": [None, None] })
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ] }]

Step 42:
  program counter:   1259
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ] }, "head"]

Step 43:
  program counter:   1260
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ] }, "head", 0]

Step 44:
  program counter:   1261
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "head", { "data": [None, None] }); add key/value pair to dictionary; push result ({ "data": [None, None], "head": 0 })
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0 }]

Step 45:
  program counter:   1262
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0 }, "tail"]

Step 46:
  program counter:   1263
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0 }, "tail", 1]

Step 47:
  program counter:   1264
  hvm code:          LoadVar n
  explanation:       push value (2) of variable "n"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0 }, "tail", 1, 2]

Step 48:
  program counter:   1265
  hvm code:          2-ary %
  explanation:       pop 2 values (2, 1); second value modulo the first; push result (1)
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0 }, "tail", 1]

Step 49:
  program counter:   1266
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (1, "tail", { "data": [None, None], "head": 0 }); add key/value pair to dictionary; push result ({ "data": [None, None], "head": 0, "tail": 1 })
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0, "tail": 1 }]

Step 50:
  program counter:   1267
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0, "tail": 1 }, "count"]

Step 51:
  program counter:   1268
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "data": [ None, None ], "head": 0, "tail": 1 }, "count", 0]

Step 52:
  program counter:   1269
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "count", { "data": [None, None], "head": 0, "tail": 1 }); add key/value pair to dictionary; push result ({ "count": 0, "data": [None, None], "head": 0, "tail": 1 })
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "tail": 1 }]

Step 53:
  program counter:   1270
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "tail": 1 }, "size"]

Step 54:
  program counter:   1271
  hvm code:          LoadVar n
  explanation:       push value (2) of variable "n"
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "tail": 1 }, "size", 2]

Step 55:
  program counter:   1272
  hvm code:          DelVar n
  explanation:       delete method variable n
  start expression:  line=9 column=70
  end expression:    line=9 column=70
  method variables:  { }

Step 56:
  program counter:   1273
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (2, "size", { "count": 0, "data": [None, None], "head": 0, "tail": 1 }); add key/value pair to dictionary; push result ({ "count": 0, "data": [None, None], "head": 0, "size": 2, "tail": 1 })
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }]

Step 57:
  program counter:   1274
  hvm code:          Push "not_full"
  explanation:       push constant "not_full"
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full"]

Step 58:
  program counter:   1275
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", []]

Step 59:
  program counter:   1276
  hvm code:          Apply PC(989)
  explanation:       pop an argument ([]) and call method (989: "Condition")
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  call trace:        __init__() --> Bdeque(2) --> Condition()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, []]

Step 60:
  program counter:   989
  hvm code:          Frame Condition()
  explanation:       pop argument () and run method "Condition"
  module:            synch
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}]

Step 61:
  program counter:   990
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^

Step 62:
  program counter:   991
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  start expression:  line=44 column=14
  end expression:    line=44 column=22
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, PC(541)]

Step 63:
  program counter:   992
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, PC(541), []]

Step 64:
  program counter:   993
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, ?PC(541)[[]]]

Step 65:
  program counter:   994
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=44 column=14
  end expression:    line=44 column=24
  call trace:        __init__() --> Bdeque(2) --> Condition() --> empty()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, [], 15906, []]

Step 66:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, [], 15906, {:}]

Step 67:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, [], 15906, {:}, {:}]

Step 68:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, [], 15906, {:}]

Step 69:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Bdeque(2) --> Condition()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}, {:}]

Step 70:
  program counter:   995
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable \"result\"
  module:            synch
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", [], 20418, {:}]

Step 71:
  program counter:   996
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Bdeque(2)
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "size": 2, "tail": 1 }, "not_full", {:}]

Step 72:
  program counter:   1277
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "not_full", { "count": 0, "data": [None, None], "head": 0, "size": 2, "tail": 1 }); add key/value pair to dictionary; push result ({ "count": 0, "data": [None, None], "head": 0, "not_full": {:}, "size": 2, "tail": 1 })
  module:            bdeque
  start statement:   line=8 column=5
  end statement:     line=11 column=5
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }]

Step 73:
  program counter:   1278
  hvm code:          Push "not_empty"
  explanation:       push constant "not_empty"
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty"]

Step 74:
  program counter:   1279
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", []]

Step 75:
  program counter:   1280
  hvm code:          Apply PC(989)
  explanation:       pop an argument ([]) and call method (989: "Condition")
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  call trace:        __init__() --> Bdeque(2) --> Condition()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, []]

Step 76:
  program counter:   989
  hvm code:          Frame Condition()
  explanation:       pop argument () and run method "Condition"
  module:            synch
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}]

Step 77:
  program counter:   990
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^

Step 78:
  program counter:   991
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  start expression:  line=44 column=14
  end expression:    line=44 column=22
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, PC(541)]

Step 79:
  program counter:   992
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, PC(541), []]

Step 80:
  program counter:   993
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, ?PC(541)[[]]]

Step 81:
  program counter:   994
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=44 column=14
  end expression:    line=44 column=24
  call trace:        __init__() --> Bdeque(2) --> Condition() --> empty()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, [], 15906, []]

Step 82:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, [], 15906, {:}]

Step 83:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, [], 15906, {:}, {:}]

Step 84:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, [], 15906, {:}]

Step 85:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Bdeque(2) --> Condition()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}, {:}]

Step 86:
  program counter:   995
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable \"result\"
  module:            synch
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", [], 20482, {:}]

Step 87:
  program counter:   996
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Bdeque(2)
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }, "not_empty", {:}]

Step 88:
  program counter:   1281
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "not_empty", { "count": 0, "data": [None, None], "head": 0, "not_full": {:}, "size": 2, "tail": 1 }); add key/value pair to dictionary; push result ({ "count": 0, "data": [None, None], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 })
  module:            bdeque
  start statement:   line=8 column=5
  end statement:     line=11 column=5
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }]

Step 89:
  program counter:   1282
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock"]

Step 90:
  program counter:   1283
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", []]

Step 91:
  program counter:   1284
  hvm code:          Apply PC(931)
  explanation:       pop an argument ([]) and call method (931: "Lock")
  source code:       .not_full: Condition(), .not_empty: Condition(), .lock: Lock()
  call trace:        __init__() --> Bdeque(2) --> Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, []]

Step 92:
  program counter:   931
  hvm code:          Frame Lock()
  explanation:       pop argument () and run method "Lock"
  module:            synch
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}]

Step 93:
  program counter:   932
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                                      ^^^^^

Step 94:
  program counter:   933
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=26 column=22
  end expression:    line=26 column=26
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, False]

Step 95:
  program counter:   934
  hvm code:          Apply PC(912)
  explanation:       pop an argument (False) and call method (912: "BinSema")
  source code:       result = BinSema(False)
                              ^^^^^^^^^^^^^^
  call trace:        __init__() --> Bdeque(2) --> Lock() --> BinSema(False)
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, False]

Step 96:
  program counter:   912
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (False), assign to initial, and run method "BinSema"
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: False }
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}]

Step 97:
  program counter:   913
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 98:
  program counter:   914
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 99:
  program counter:   915
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, False]

Step 100:
  program counter:   916
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, False, {}]

Step 101:
  program counter:   917
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, False, {}, False]

Step 102:
  program counter:   918
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, False, { False }]

Step 103:
  program counter:   919
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, False, { False }, True]

Step 104:
  program counter:   920
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, False, { False, True }]

Step 105:
  program counter:   921
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, False); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, True]

Step 106:
  program counter:   922
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}]

Step 107:
  program counter:   923
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 108:
  program counter:   924
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 109:
  program counter:   925
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}, False]

Step 110:
  program counter:   926
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 111:
  program counter:   927
  hvm code:          StoreVar sema
  explanation:       pop value (False) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: False }
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, [], 14946, {:}]

Step 112:
  program counter:   928
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Bdeque(2) --> Lock()
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}, False]

Step 113:
  program counter:   935
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable \"result\"
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", [], 20546, {:}]

Step 114:
  program counter:   936
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Bdeque(2)
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }, "lock", False]

Step 115:
  program counter:   1285
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "lock", { "count": 0, "data": [None, None], "head": 0, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }); add key/value pair to dictionary; push result ({ "count": 0, "data": [None, None], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 })
  module:            bdeque
  start statement:   line=8 column=5
  end statement:     line=11 column=5
  source code:       .data: [None,] *n, .head: 0, .tail: 1 % n, .count: 0, .size: n, 
  stack:             [{:}, [], 27618, {:}, { "count": 0, "data": [ None, None ], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }]

Step 116:
  program counter:   1286
  hvm code:          StoreVar initial
  explanation:       pop value ({ "count": 0, "data": [None, None], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }) and store locally in variable \"initial\"
  source code:       initial = { 
  method variables:  { initial: { "count": 0, "data": [ None, None ], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 } }
  stack:             [{:}, [], 27618, {:}]

Step 117:
  program counter:   1287
  hvm code:          ReturnOp(initial)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=4 column=1
  end statement:     line=4 column=30
  source code:       def Bdeque(n) returns initial:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__()
  stack:             [{:}, { "count": 0, "data": [ None, None ], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }]

Step 118:
  program counter:   1727
  hvm code:          Store d
  explanation:       pop value ({ "count": 0, "data": [None, None], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }) and store into variable d
  module:            __main__
  start statement:   line=10 column=1
  end statement:     line=10 column=23
  source code:       d = bdeque.Bdeque(SIZE)
                     ^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 0, "data": [ None, None ], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 } }
  stack:             [{:}]

Step 119:
  program counter:   1728
  hvm code:          Jump 1882
  explanation:       jump over method definition: set program counter to 1882
  start statement:   line=12 column=1
  end statement:     line=12 column=24
  source code:       def put_left_test(self):
                     ^^^

Step 120:
  program counter:   1882
  hvm code:          Push 1
  explanation:       push constant 1
  start statement:   line=43 column=1
  end statement:     line=43 column=24
  source code:       for i in {1..N_PUT_LEFT}:
                               ^
  stack:             [{:}, 1]

Step 121:
  program counter:   1883
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       for i in {1..N_PUT_LEFT}:
                                  ^^^^^^^^^^
  stack:             [{:}, 1, 1]

Step 122:
  program counter:   1884
  hvm code:          2-ary ..
  explanation:       pop 2 values (1, 1); range of integers; push result ({ 1 })
  source code:       for i in {1..N_PUT_LEFT}:
                               ^^^^^^^^^^^^^
  stack:             [{:}, { 1 }]

Step 123:
  program counter:   1885
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_PUT_LEFT}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 124:
  program counter:   1886
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=43 column=1
  end expression:    line=43 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1 }, 1, True]

Step 125:
  program counter:   1887
  hvm code:          JumpCond False 1895
  explanation:       pop value (True), compare to False, and jump to 1895 if the same
  start expression:  line=43 column=1
  end expression:    line=43 column=3
  stack:             [{:}, { 1 }, 1]

Step 126:
  program counter:   1888
  hvm code:          Push ?PC(1729)
  explanation:       push constant ?PC(1729)
  start statement:   line=44 column=5
  end statement:     line=44 column=26
  source code:       spawn put_left_test(i)
                           ^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1729)]

Step 127:
  program counter:   1889
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn put_left_test(i)
                                         ^
  stack:             [{:}, { 1 }, 1, ?PC(1729), 1]

Step 128:
  program counter:   1890
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=44 column=25
  end expression:    line=44 column=25
  method variables:  { }

Step 129:
  program counter:   1891
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1729)); push result (?PC(1729)[1])
  source code:       spawn put_left_test(i)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1729)[1]]

Step 130:
  program counter:   1892
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn put_left_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1729)[1], {:}]

Step 131:
  program counter:   1893
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1729: "put_left_test"), and spawn thread
  start expression:  line=44 column=5
  end expression:    line=44 column=26
  stack:             [{:}, { 1 }, 1]

Step 132:
  program counter:   1894
  hvm code:          Jump 1886
  explanation:       set program counter to 1886
  start statement:   line=43 column=1
  end statement:     line=43 column=24
  source code:       for i in {1..N_PUT_LEFT}:
                                            ^

Step 133:
  program counter:   1886
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..N_PUT_LEFT}:
                     ^^^
  stack:             [{:}, False]

Step 134:
  program counter:   1887
  hvm code:          JumpCond False 1895
  explanation:       pop value (False), compare to False, and jump to 1895 if the same
  start expression:  line=43 column=1
  end expression:    line=43 column=3
  stack:             [{:}]

Step 135:
  program counter:   1895
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=45 column=1
  end statement:     line=45 column=25
  source code:       for i in {1..N_PUT_RIGHT}:
                               ^

Step 136:
  program counter:   1896
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=45 column=11
  end expression:    line=45 column=11
  stack:             [{:}, 1]

Step 137:
  program counter:   1897
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       for i in {1..N_PUT_RIGHT}:
                                  ^^^^^^^^^^^
  stack:             [{:}, 1, 2]

Step 138:
  program counter:   1898
  hvm code:          2-ary ..
  explanation:       pop 2 values (2, 1); range of integers; push result ({ 1, 2 })
  source code:       for i in {1..N_PUT_RIGHT}:
                               ^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }]

Step 139:
  program counter:   1899
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_PUT_RIGHT}:
                     ^^^
  stack:             [{:}, { 1, 2 }, 0]

Step 140:
  program counter:   1900
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1, 2 }); assign value (1) to i; push new index (1) and True
  start expression:  line=45 column=1
  end expression:    line=45 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1, 2 }, 1, True]

Step 141:
  program counter:   1901
  hvm code:          JumpCond False 1909
  explanation:       pop value (True), compare to False, and jump to 1909 if the same
  start expression:  line=45 column=1
  end expression:    line=45 column=3
  stack:             [{:}, { 1, 2 }, 1]

Step 142:
  program counter:   1902
  hvm code:          Push ?PC(1758)
  explanation:       push constant ?PC(1758)
  start statement:   line=46 column=5
  end statement:     line=46 column=27
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1758)]

Step 143:
  program counter:   1903
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn put_right_test(i)
                                          ^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1758), 1]

Step 144:
  program counter:   1904
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=46 column=26
  end expression:    line=46 column=26
  method variables:  { }

Step 145:
  program counter:   1905
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1758)); push result (?PC(1758)[1])
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1758)[1]]

Step 146:
  program counter:   1906
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn put_right_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1758)[1], {:}]

Step 147:
  program counter:   1907
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1758: "put_right_test"), and spawn thread
  start expression:  line=46 column=5
  end expression:    line=46 column=27
  stack:             [{:}, { 1, 2 }, 1]

Step 148:
  program counter:   1908
  hvm code:          Jump 1900
  explanation:       set program counter to 1900
  start statement:   line=45 column=1
  end statement:     line=45 column=25
  source code:       for i in {1..N_PUT_RIGHT}:
                                             ^

Step 149:
  program counter:   1900
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1, 2 }); assign value (2) to i; push new index (2) and True
  source code:       for i in {1..N_PUT_RIGHT}:
                     ^^^
  method variables:  { i: 2 }
  stack:             [{:}, { 1, 2 }, 2, True]

Step 150:
  program counter:   1901
  hvm code:          JumpCond False 1909
  explanation:       pop value (True), compare to False, and jump to 1909 if the same
  start expression:  line=45 column=1
  end expression:    line=45 column=3
  stack:             [{:}, { 1, 2 }, 2]

Step 151:
  program counter:   1902
  hvm code:          Push ?PC(1758)
  explanation:       push constant ?PC(1758)
  start statement:   line=46 column=5
  end statement:     line=46 column=27
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1758)]

Step 152:
  program counter:   1903
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       spawn put_right_test(i)
                                          ^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1758), 2]

Step 153:
  program counter:   1904
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=46 column=26
  end expression:    line=46 column=26
  method variables:  { }

Step 154:
  program counter:   1905
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (2, ?PC(1758)); push result (?PC(1758)[2])
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1758)[2]]

Step 155:
  program counter:   1906
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn put_right_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1758)[2], {:}]

Step 156:
  program counter:   1907
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (2), and pc (1758: "put_right_test"), and spawn thread
  start expression:  line=46 column=5
  end expression:    line=46 column=27
  stack:             [{:}, { 1, 2 }, 2]

Step 157:
  program counter:   1908
  hvm code:          Jump 1900
  explanation:       set program counter to 1900
  start statement:   line=45 column=1
  end statement:     line=45 column=25
  source code:       for i in {1..N_PUT_RIGHT}:
                                             ^

Step 158:
  program counter:   1900
  hvm code:          Cut(i)
  explanation:       pop index (2) and value ({ 1, 2 }); out of range -> push False
  source code:       for i in {1..N_PUT_RIGHT}:
                     ^^^
  stack:             [{:}, False]

Step 159:
  program counter:   1901
  hvm code:          JumpCond False 1909
  explanation:       pop value (False), compare to False, and jump to 1909 if the same
  start expression:  line=45 column=1
  end expression:    line=45 column=3
  stack:             [{:}]

Step 160:
  program counter:   1909
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=47 column=1
  end statement:     line=47 column=24
  source code:       for i in {1..N_GET_LEFT}:
                               ^

Step 161:
  program counter:   1910
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=47 column=11
  end expression:    line=47 column=11
  stack:             [{:}, 1]

Step 162:
  program counter:   1911
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       for i in {1..N_GET_LEFT}:
                                  ^^^^^^^^^^
  stack:             [{:}, 1, 1]

Step 163:
  program counter:   1912
  hvm code:          2-ary ..
  explanation:       pop 2 values (1, 1); range of integers; push result ({ 1 })
  source code:       for i in {1..N_GET_LEFT}:
                               ^^^^^^^^^^^^^
  stack:             [{:}, { 1 }]

Step 164:
  program counter:   1913
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_GET_LEFT}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 165:
  program counter:   1914
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=47 column=1
  end expression:    line=47 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1 }, 1, True]

Step 166:
  program counter:   1915
  hvm code:          JumpCond False 1923
  explanation:       pop value (True), compare to False, and jump to 1923 if the same
  start expression:  line=47 column=1
  end expression:    line=47 column=3
  stack:             [{:}, { 1 }, 1]

Step 167:
  program counter:   1916
  hvm code:          Push ?PC(1787)
  explanation:       push constant ?PC(1787)
  start statement:   line=48 column=5
  end statement:     line=48 column=26
  source code:       spawn get_left_test(i)
                           ^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1787)]

Step 168:
  program counter:   1917
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn get_left_test(i)
                                         ^
  stack:             [{:}, { 1 }, 1, ?PC(1787), 1]

Step 169:
  program counter:   1918
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=48 column=25
  end expression:    line=48 column=25
  method variables:  { }

Step 170:
  program counter:   1919
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1787)); push result (?PC(1787)[1])
  source code:       spawn get_left_test(i)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1787)[1]]

Step 171:
  program counter:   1920
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn get_left_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1787)[1], {:}]

Step 172:
  program counter:   1921
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1787: "get_left_test"), and spawn thread
  start expression:  line=48 column=5
  end expression:    line=48 column=26
  stack:             [{:}, { 1 }, 1]

Step 173:
  program counter:   1922
  hvm code:          Jump 1914
  explanation:       set program counter to 1914
  start statement:   line=47 column=1
  end statement:     line=47 column=24
  source code:       for i in {1..N_GET_LEFT}:
                                            ^

Step 174:
  program counter:   1914
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..N_GET_LEFT}:
                     ^^^
  stack:             [{:}, False]

Step 175:
  program counter:   1915
  hvm code:          JumpCond False 1923
  explanation:       pop value (False), compare to False, and jump to 1923 if the same
  start expression:  line=47 column=1
  end expression:    line=47 column=3
  stack:             [{:}]

Step 176:
  program counter:   1923
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=49 column=1
  end statement:     line=49 column=25
  source code:       for i in {1..N_GET_RIGHT}:
                               ^

Step 177:
  program counter:   1924
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=49 column=11
  end expression:    line=49 column=11
  stack:             [{:}, 1]

Step 178:
  program counter:   1925
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       for i in {1..N_GET_RIGHT}:
                                  ^^^^^^^^^^^
  stack:             [{:}, 1, 1]

Step 179:
  program counter:   1926
  hvm code:          2-ary ..
  explanation:       pop 2 values (1, 1); range of integers; push result ({ 1 })
  source code:       for i in {1..N_GET_RIGHT}:
                               ^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }]

Step 180:
  program counter:   1927
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_GET_RIGHT}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 181:
  program counter:   1928
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=49 column=1
  end expression:    line=49 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1 }, 1, True]

Step 182:
  program counter:   1929
  hvm code:          JumpCond False 1937
  explanation:       pop value (True), compare to False, and jump to 1937 if the same
  start expression:  line=49 column=1
  end expression:    line=49 column=3
  stack:             [{:}, { 1 }, 1]

Step 183:
  program counter:   1930
  hvm code:          Push ?PC(1811)
  explanation:       push constant ?PC(1811)
  start statement:   line=50 column=5
  end statement:     line=50 column=27
  source code:       spawn get_right_test(i)
                           ^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1811)]

Step 184:
  program counter:   1931
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn get_right_test(i)
                                          ^
  stack:             [{:}, { 1 }, 1, ?PC(1811), 1]

Step 185:
  program counter:   1932
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=50 column=26
  end expression:    line=50 column=26
  method variables:  { }

Step 186:
  program counter:   1933
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1811)); push result (?PC(1811)[1])
  source code:       spawn get_right_test(i)
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1811)[1]]

Step 187:
  program counter:   1934
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn get_right_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1811)[1], {:}]

Step 188:
  program counter:   1935
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1811: "get_right_test"), and spawn thread
  start expression:  line=50 column=5
  end expression:    line=50 column=27
  stack:             [{:}, { 1 }, 1]

Step 189:
  program counter:   1936
  hvm code:          Jump 1928
  explanation:       set program counter to 1928
  start statement:   line=49 column=1
  end statement:     line=49 column=25
  source code:       for i in {1..N_GET_RIGHT}:
                                             ^

Step 190:
  program counter:   1928
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..N_GET_RIGHT}:
                     ^^^
  stack:             [{:}, False]

Step 191:
  program counter:   1929
  hvm code:          JumpCond False 1937
  explanation:       pop value (False), compare to False, and jump to 1937 if the same
  start expression:  line=49 column=1
  end expression:    line=49 column=3
  stack:             [{:}]

Step 192:
  program counter:   1937
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=51 column=1
  end statement:     line=51 column=25
  source code:       for i in {1..N_PEEK_LEFT}:
                               ^

Step 193:
  program counter:   1938
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=51 column=11
  end expression:    line=51 column=11
  stack:             [{:}, 1]

Step 194:
  program counter:   1939
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_PEEK_LEFT}:
                                  ^^^^^^^^^^^
  stack:             [{:}, 1, 0]

Step 195:
  program counter:   1940
  hvm code:          2-ary ..
  explanation:       pop 2 values (0, 1); range of integers; push result ({})
  source code:       for i in {1..N_PEEK_LEFT}:
                               ^^^^^^^^^^^^^^
  stack:             [{:}, {}]

Step 196:
  program counter:   1941
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_PEEK_LEFT}:
                     ^^^
  stack:             [{:}, {}, 0]

Step 197:
  program counter:   1942
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({}); out of range -> push False
  start expression:  line=51 column=1
  end expression:    line=51 column=3
  stack:             [{:}, False]

Step 198:
  program counter:   1943
  hvm code:          JumpCond False 1951
  explanation:       pop value (False), compare to False, and jump to 1951 if the same
  start expression:  line=51 column=1
  end expression:    line=51 column=3
  stack:             [{:}]

Step 199:
  program counter:   1951
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=53 column=1
  end statement:     line=53 column=26
  source code:       for i in {1..N_PEEK_RIGHT}:
                               ^

Step 200:
  program counter:   1952
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=53 column=11
  end expression:    line=53 column=11
  stack:             [{:}, 1]

Step 201:
  program counter:   1953
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       for i in {1..N_PEEK_RIGHT}:
                                  ^^^^^^^^^^^^
  stack:             [{:}, 1, 1]

Step 202:
  program counter:   1954
  hvm code:          2-ary ..
  explanation:       pop 2 values (1, 1); range of integers; push result ({ 1 })
  source code:       for i in {1..N_PEEK_RIGHT}:
                               ^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }]

Step 203:
  program counter:   1955
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_PEEK_RIGHT}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 204:
  program counter:   1956
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=53 column=1
  end expression:    line=53 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1 }, 1, True]

Step 205:
  program counter:   1957
  hvm code:          JumpCond False 1965
  explanation:       pop value (True), compare to False, and jump to 1965 if the same
  start expression:  line=53 column=1
  end expression:    line=53 column=3
  stack:             [{:}, { 1 }, 1]

Step 206:
  program counter:   1958
  hvm code:          Push ?PC(1859)
  explanation:       push constant ?PC(1859)
  start statement:   line=54 column=5
  end statement:     line=54 column=28
  source code:       spawn peek_right_test(i)
                           ^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1859)]

Step 207:
  program counter:   1959
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn peek_right_test(i)
                                           ^
  stack:             [{:}, { 1 }, 1, ?PC(1859), 1]

Step 208:
  program counter:   1960
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=54 column=27
  end expression:    line=54 column=27
  method variables:  { }

Step 209:
  program counter:   1961
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1859)); push result (?PC(1859)[1])
  source code:       spawn peek_right_test(i)
                           ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1859)[1]]

Step 210:
  program counter:   1962
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn peek_right_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1859)[1], {:}]

Step 211:
  program counter:   1963
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1859: "peek_right_test"), and spawn thread
  start expression:  line=54 column=5
  end expression:    line=54 column=28
  stack:             [{:}, { 1 }, 1]

Step 212:
  program counter:   1964
  hvm code:          Jump 1956
  explanation:       set program counter to 1956
  start statement:   line=53 column=1
  end statement:     line=53 column=26
  source code:       for i in {1..N_PEEK_RIGHT}:
                                              ^

Step 213:
  program counter:   1956
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..N_PEEK_RIGHT}:
                     ^^^
  stack:             [{:}, False]

Step 214:
  program counter:   1957
  hvm code:          JumpCond False 1965
  explanation:       pop value (False), compare to False, and jump to 1965 if the same
  start expression:  line=53 column=1
  end expression:    line=53 column=3
  stack:             [{:}]

Step 215:
  program counter:   1965
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=1 column=1
  end statement:     line=56 column=10
  source code:       import bdeque

Step 216:
  program counter:   1966
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start expression:  line=1 column=1
  end expression:    line=56 column=10
  new mode:          terminated
  stack:             [None]

================================================
Running thread T3: put_right_test(2)
mode:  runnable
stack: ['2']
other threads:
  T0: pc=1966 terminated atomic __init__()
  T1: pc=1729 runnable put_left_test(1)
    about to run method put_left_test with argument 1
  T2: pc=1758 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T4: pc=1787 runnable get_left_test(1)
    about to run method get_left_test with argument 1
  T5: pc=1811 runnable get_right_test(1)
    about to run method get_right_test with argument 1
  T6: pc=1859 runnable peek_right_test(1)
    about to run method peek_right_test with argument 1
shared variables:
  alloc$next: 0
  alloc$pool: {:}
  d: { "count": 0, "data": [ None, None ], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 }
state id: 4
================================================

Step 217:
  program counter:   1758
  hvm code:          Frame put_right_test(self)
  explanation:       pop argument (2), assign to self, and run method "put_right_test"
  start statement:   line=17 column=1
  end statement:     line=17 column=25
  source code:       def put_right_test(self):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 2 }
  call trace:        put_right_test(2)
  stack:             [{:}]

Step 218:
  program counter:   1759
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=18 column=5
  end statement:     line=18 column=33
  source code:       print("call right put", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 219:
  program counter:   1760
  hvm code:          Push "call right put"
  explanation:       push constant "call right put"
  source code:       print("call right put", self)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], "call right put"]

Step 220:
  program counter:   1761
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call right put", []); insert first value into the second; push result (["call right put"])
  source code:       print("call right put", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call right put" ]]

Step 221:
  program counter:   1762
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       print("call right put", self)
                                             ^^^^
  stack:             [{:}, [ "call right put" ], 2]

Step 222:
  program counter:   1763
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, ["call right put"]); insert first value into the second; push result (["call right put", 2])
  source code:       print("call right put", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call right put", 2 ]]

Step 223:
  program counter:   1764
  hvm code:          Print
  explanation:       pop value (["call right put", 2]) and add to print log
  source code:       print("call right put", self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_right_test(2)
  stack:             [{:}]

Step 224:
  program counter:   1765
  hvm code:          Push PC(1372)
  explanation:       push program counter constant 1372 ()
  start statement:   line=19 column=5
  end statement:     line=19 column=42
  source code:       bdeque.put_right(?d, (self, "rights"))
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1372)]

Step 225:
  program counter:   1766
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       bdeque.put_right(?d, (self, "rights"))
                                      ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1372), []]

Step 226:
  program counter:   1767
  hvm code:          Push ?d
  explanation:       push constant ?d
  source code:       bdeque.put_right(?d, (self, "rights"))
                                       ^
  stack:             [{:}, PC(1372), [], ?d]

Step 227:
  program counter:   1768
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?d, []); insert first value into the second; push result ([?d])
  source code:       bdeque.put_right(?d, (self, "rights"))
                                      ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1372), [ ?d ]]

Step 228:
  program counter:   1769
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       bdeque.put_right(?d, (self, "rights"))
                                           ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1372), [ ?d ], []]

Step 229:
  program counter:   1770
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       bdeque.put_right(?d, (self, "rights"))
                                           ^^^^
  stack:             [{:}, PC(1372), [ ?d ], [], 2]

Step 230:
  program counter:   1771
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       bdeque.put_right(?d, (self, "rights"))
                                           ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1372), [ ?d ], [ 2 ]]

Step 231:
  program counter:   1772
  hvm code:          Push "rights"
  explanation:       push constant "rights"
  source code:       bdeque.put_right(?d, (self, "rights"))
                                                 ^^^^^^^^
  stack:             [{:}, PC(1372), [ ?d ], [ 2 ], "rights"]

Step 232:
  program counter:   1773
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("rights", [2]); insert first value into the second; push result ([2, "rights"])
  source code:       bdeque.put_right(?d, (self, "rights"))
                                           ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1372), [ ?d ], [ 2, "rights" ]]

Step 233:
  program counter:   1774
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([2, "rights"], [?d]); insert first value into the second; push result ([?d, [2, "rights"]])
  source code:       bdeque.put_right(?d, (self, "rights"))
                                      ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1372), [ ?d, [ 2, "rights" ] ]]

Step 234:
  program counter:   1775
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([?d, [2, "rights"]], PC(1372)); push result (?PC(1372)[[?d, [2, "rights"]]])
  source code:       bdeque.put_right(?d, (self, "rights"))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1372)[[ ?d, [ 2, "rights" ] ]]]

Step 235:
  program counter:   1776
  hvm code:          Load
  explanation:       pop an argument ([?d, [2, "rights"]]) and call method (1372: "put_right")
  start expression:  line=19 column=5
  end expression:    line=19 column=42
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, [ ?d, [ 2, "rights" ] ]]

Step 236:
  program counter:   1372
  hvm code:          Frame put_right(d, v)
  explanation:       pop argument ([?d, [2, "rights"]]), assign to (d, v), and run method "put_right"
  module:            bdeque
  start statement:   line=34 column=1
  end statement:     line=34 column=20
  source code:       def put_right(d, v):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d, v: [ 2, "rights" ] }
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 237:
  program counter:   1373
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=40 column=5
  end statement:     line=40 column=21
  source code:       acquire(?d->lock)
                              ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 238:
  program counter:   1374
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "lock"]

Step 239:
  program counter:   1375
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       acquire(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["lock"]]

Step 240:
  program counter:   1376
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?d["lock"]) and call method (954: "acquire")
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> acquire(?d["lock"])
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, ?d["lock"]]

Step 241:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }]

Step 242:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> acquire(?d["lock"])

Step 243:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 244:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }, ?d["lock"]]

Step 245:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }, False]

Step 246:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }, True]

Step 247:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }]

Step 248:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 249:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 250:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }, ?d["lock"]]

Step 251:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 252:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }, ?d["lock"], True]

Step 253:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?d["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 0, "data": [ None, None ], "head": 0, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 } }
  stack:             [{:}, [], 28418, { "self": 2 }, [], 22018, { "d": ?d, "v": [ 2, "rights" ] }]

Step 254:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 255:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d, v: [ 2, "rights" ] }
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, None]

Step 256:
  program counter:   1377
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=40 column=5
  end statement:     line=40 column=21
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 257:
  program counter:   1378
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=41 column=5
  end statement:     line=41 column=30
  source code:       while d->count == d->size:
                           ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 258:
  program counter:   1379
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       while d->count == d->size:
                              ^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "count"]

Step 259:
  program counter:   1380
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       while d->count == d->size:
                           ^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["count"]]

Step 260:
  program counter:   1381
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (0)
  start expression:  line=41 column=11
  end expression:    line=41 column=18
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, 0]

Step 261:
  program counter:   1382
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       while d->count == d->size:
                                       ^
  stack:             [{:}, [], 28418, { "self": 2 }, 0, ?d]

Step 262:
  program counter:   1383
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       while d->count == d->size:
                                          ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, 0, ?d, "size"]

Step 263:
  program counter:   1384
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("size", ?d); push result (?d["size"])
  source code:       while d->count == d->size:
                                       ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, 0, ?d["size"]]

Step 264:
  program counter:   1385
  hvm code:          Load
  explanation:       pop address (?d["size"]) and push value (2)
  start expression:  line=41 column=23
  end expression:    line=41 column=29
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, 0, 2]

Step 265:
  program counter:   1386
  hvm code:          2-ary ==
  explanation:       pop 2 values (2, 0); check if both values are the same; push result (False)
  source code:       while d->count == d->size:
                           ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, False]

Step 266:
  program counter:   1387
  hvm code:          JumpCond False 1400
  explanation:       pop value (False), compare to False, and jump to 1400 if the same
  source code:       while d->count == d->size:
                     ^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 267:
  program counter:   1400
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=43 column=5
  end statement:     line=43 column=24
  source code:       d->data[d->tail] = v 
                     ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 268:
  program counter:   1401
  hvm code:          Push "data"
  explanation:       push constant "data"
  source code:       d->data[d->tail] = v 
                        ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "data"]

Step 269:
  program counter:   1402
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("data", ?d); push result (?d["data"])
  source code:       d->data[d->tail] = v 
                     ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["data"]]

Step 270:
  program counter:   1403
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->data[d->tail] = v 
                             ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["data"], ?d]

Step 271:
  program counter:   1404
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       d->data[d->tail] = v 
                                ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["data"], ?d, "tail"]

Step 272:
  program counter:   1405
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("tail", ?d); push result (?d["tail"])
  source code:       d->data[d->tail] = v 
                             ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["data"], ?d["tail"]]

Step 273:
  program counter:   1406
  hvm code:          Load
  explanation:       pop address (?d["tail"]) and push value (1)
  start expression:  line=43 column=13
  end expression:    line=43 column=19
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["data"], 1]

Step 274:
  program counter:   1407
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?d["data"]); push result (?d["data"][1])
  source code:       d->data[d->tail] = v 
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["data"][1]]

Step 275:
  program counter:   1408
  hvm code:          LoadVar v
  explanation:       push value ([2, "rights"]) of variable "v"
  source code:       d->data[d->tail] = v 
                                        ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["data"][1], [ 2, "rights" ]]

Step 276:
  program counter:   1409
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=43 column=24
  end expression:    line=43 column=24
  method variables:  { d: ?d }

Step 277:
  program counter:   1410
  hvm code:          Store
  explanation:       pop value ([2, "rights"]) and address (?d["data"][1]) and store
  source code:       d->data[d->tail] = v 
                     ^^^^^^^^^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 0, "data": [ None, [ 2, "rights" ] ], "head": 0, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 1 } }
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 278:
  program counter:   1411
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=44 column=5
  end statement:     line=44 column=37
  source code:       d->tail = (d->tail + 1) % d->size
                     ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 279:
  program counter:   1412
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       d->tail = (d->tail + 1) % d->size
                        ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "tail"]

Step 280:
  program counter:   1413
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("tail", ?d); push result (?d["tail"])
  source code:       d->tail = (d->tail + 1) % d->size
                     ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"]]

Step 281:
  program counter:   1414
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->tail = (d->tail + 1) % d->size
                                ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], ?d]

Step 282:
  program counter:   1415
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       d->tail = (d->tail + 1) % d->size
                                   ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], ?d, "tail"]

Step 283:
  program counter:   1416
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("tail", ?d); push result (?d["tail"])
  source code:       d->tail = (d->tail + 1) % d->size
                                ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], ?d["tail"]]

Step 284:
  program counter:   1417
  hvm code:          Load
  explanation:       pop address (?d["tail"]) and push value (1)
  start expression:  line=44 column=16
  end expression:    line=44 column=22
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 1]

Step 285:
  program counter:   1418
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       d->tail = (d->tail + 1) % d->size
                                          ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 1, 1]

Step 286:
  program counter:   1419
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 1); add the integers; push result (2)
  source code:       d->tail = (d->tail + 1) % d->size
                                ^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 2]

Step 287:
  program counter:   1420
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->tail = (d->tail + 1) % d->size
                                               ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 2, ?d]

Step 288:
  program counter:   1421
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       d->tail = (d->tail + 1) % d->size
                                                  ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 2, ?d, "size"]

Step 289:
  program counter:   1422
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("size", ?d); push result (?d["size"])
  source code:       d->tail = (d->tail + 1) % d->size
                                               ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 2, ?d["size"]]

Step 290:
  program counter:   1423
  hvm code:          Load
  explanation:       pop address (?d["size"]) and push value (2)
  start expression:  line=44 column=31
  end expression:    line=44 column=37
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 2, 2]

Step 291:
  program counter:   1424
  hvm code:          2-ary %
  explanation:       pop 2 values (2, 2); second value modulo the first; push result (0)
  source code:       d->tail = (d->tail + 1) % d->size
                               ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["tail"], 0]

Step 292:
  program counter:   1425
  hvm code:          Store
  explanation:       pop value (0) and address (?d["tail"]) and store
  source code:       d->tail = (d->tail + 1) % d->size
                     ^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 0, "data": [ None, [ 2, "rights" ] ], "head": 0, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 293:
  program counter:   1426
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=45 column=5
  end statement:     line=45 column=17
  source code:       d->count += 1
                     ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 294:
  program counter:   1427
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       d->count += 1
                        ^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "count"]

Step 295:
  program counter:   1428
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       d->count += 1
                     ^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["count"]]

Step 296:
  program counter:   1429
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       d->count += 1
                     ^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["count"], ?d["count"]]

Step 297:
  program counter:   1430
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (0)
  start expression:  line=45 column=5
  end expression:    line=45 column=17
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["count"], 0]

Step 298:
  program counter:   1431
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       d->count += 1
                                 ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["count"], 0, 1]

Step 299:
  program counter:   1432
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       d->count += 1
                     ^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["count"], 1]

Step 300:
  program counter:   1433
  hvm code:          Store
  explanation:       pop value (1) and address (?d["count"]) and store
  source code:       d->count += 1
                     ^^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 1, "data": [ None, [ 2, "rights" ] ], "head": 0, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 301:
  program counter:   1434
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=47 column=5
  end statement:     line=47 column=21
  source code:       if d->count == 1:
                        ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 302:
  program counter:   1435
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       if d->count == 1:
                           ^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "count"]

Step 303:
  program counter:   1436
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       if d->count == 1:
                        ^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["count"]]

Step 304:
  program counter:   1437
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (1)
  start expression:  line=47 column=8
  end expression:    line=47 column=15
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, 1]

Step 305:
  program counter:   1438
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       if d->count == 1:
                                    ^
  stack:             [{:}, [], 28418, { "self": 2 }, 1, 1]

Step 306:
  program counter:   1439
  hvm code:          2-ary ==
  explanation:       pop 2 values (1, 1); check if both values are the same; push result (True)
  source code:       if d->count == 1:
                        ^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, True]

Step 307:
  program counter:   1440
  hvm code:          JumpCond False 1446
  explanation:       pop value (True), compare to False, and jump to 1446 if the same
  source code:       if d->count == 1:
                     ^^
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 308:
  program counter:   1441
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=48 column=9
  end statement:     line=48 column=32
  source code:       notifyAll(?d->not_empty) 
                                ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 309:
  program counter:   1442
  hvm code:          Push "not_empty"
  explanation:       push constant "not_empty"
  source code:       notifyAll(?d->not_empty) 
                                   ^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "not_empty"]

Step 310:
  program counter:   1443
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("not_empty", ?d); push result (?d["not_empty"])
  source code:       notifyAll(?d->not_empty) 
                                ^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["not_empty"]]

Step 311:
  program counter:   1444
  hvm code:          Apply PC(1097)
  explanation:       pop an argument (?d["not_empty"]) and call method (1097: "notifyAll")
  source code:       notifyAll(?d->not_empty) 
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> notifyAll(?d["not_empty"])
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, ?d["not_empty"]]

Step 312:
  program counter:   1097
  hvm code:          Frame notifyAll(c)
  explanation:       pop argument (?d["not_empty"]), assign to c, and run method "notifyAll"
  module:            synch
  start statement:   line=60 column=1
  end statement:     line=60 column=17
  source code:       def notifyAll(c):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { c: ?d["not_empty"] }
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }]

Step 313:
  program counter:   1098
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=61 column=16
  end statement:     line=61 column=31
  source code:       atomically !c = bag.empty()
                                ^^^^^^^^^^^^^^^^
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> notifyAll(?d["not_empty"])

Step 314:
  program counter:   1099
  hvm code:          LoadVar c
  explanation:       push value (?d["not_empty"]) of variable "c"
  source code:       atomically !c = bag.empty()
                                 ^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"]]

Step 315:
  program counter:   1100
  hvm code:          DelVar c
  explanation:       delete method variable c
  start expression:  line=61 column=17
  end expression:    line=61 column=17
  method variables:  { }

Step 316:
  program counter:   1101
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically !c = bag.empty()
                                     ^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], PC(541)]

Step 317:
  program counter:   1102
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically !c = bag.empty()
                                              ^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], PC(541), []]

Step 318:
  program counter:   1103
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically !c = bag.empty()
                                     ^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], ?PC(541)[[]]]

Step 319:
  program counter:   1104
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=61 column=21
  end expression:    line=61 column=31
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> notifyAll(?d["not_empty"]) --> empty()
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], [], 17666, []]

Step 320:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], [], 17666, {:}]

Step 321:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], [], 17666, {:}, {:}]

Step 322:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], [], 17666, {:}]

Step 323:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> notifyAll(?d["not_empty"])
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }, ?d["not_empty"], {:}]

Step 324:
  program counter:   1105
  hvm code:          Store
  explanation:       pop value ({:}) and address (?d["not_empty"]) and store
  module:            synch
  start statement:   line=61 column=16
  end statement:     line=61 column=31
  source code:       atomically !c = bag.empty()
                                ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23106, { "d": ?d }]

Step 325:
  program counter:   1106
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  source code:       atomically !c = bag.empty()
                                ^^^^^^^^^^^^^^^^

Step 326:
  program counter:   1107
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=60 column=1
  end statement:     line=60 column=17
  source code:       def notifyAll(c):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d }
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, None]

Step 327:
  program counter:   1445
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=48 column=9
  end statement:     line=48 column=32
  source code:       notifyAll(?d->not_empty) 
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 328:
  program counter:   1446
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=49 column=5
  end statement:     line=49 column=21
  source code:       release(?d->lock)
                              ^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d]

Step 329:
  program counter:   1447
  hvm code:          DelVar d
  explanation:       delete method variable d
  start expression:  line=49 column=14
  end expression:    line=49 column=14
  method variables:  { }

Step 330:
  program counter:   1448
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d, "lock"]

Step 331:
  program counter:   1449
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       release(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, ?d["lock"]]

Step 332:
  program counter:   1450
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?d["lock"]) and call method (973: "release")
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> release(?d["lock"])
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, ?d["lock"]]

Step 333:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, {:}]

Step 334:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"]) --> release(?d["lock"])

Step 335:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 336:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 337:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, {:}, ?d["lock"]]

Step 338:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, {:}, True]

Step 339:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, {:}]

Step 340:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 341:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 342:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, {:}, ?d["lock"]]

Step 343:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 344:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, {:}, ?d["lock"], False]

Step 345:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?d["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 1, "data": [ None, [ 2, "rights" ] ], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  stack:             [{:}, [], 28418, { "self": 2 }, [], 23202, {:}]

Step 346:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 347:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_right_test(2) --> put_right(?d, [2, "rights"])
  stack:             [{:}, [], 28418, { "self": 2 }, None]

Step 348:
  program counter:   1451
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=49 column=5
  end statement:     line=49 column=21
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 28418, { "self": 2 }]

Step 349:
  program counter:   1452
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=20
  source code:       def put_right(d, v):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 2 }
  call trace:        put_right_test(2)
  stack:             [{:}, None]

Step 350:
  program counter:   1777
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=19 column=5
  end statement:     line=19 column=42
  source code:       bdeque.put_right(?d, (self, "rights"))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 351:
  program counter:   1778
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=20 column=5
  end statement:     line=20 column=33
  source code:       print("done right put", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 352:
  program counter:   1779
  hvm code:          Push "done right put"
  explanation:       push constant "done right put"
  source code:       print("done right put", self)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], "done right put"]

Step 353:
  program counter:   1780
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("done right put", []); insert first value into the second; push result (["done right put"])
  source code:       print("done right put", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done right put" ]]

Step 354:
  program counter:   1781
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       print("done right put", self)
                                             ^^^^
  stack:             [{:}, [ "done right put" ], 2]

Step 355:
  program counter:   1782
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=20 column=29
  end expression:    line=20 column=32
  method variables:  { }

Step 356:
  program counter:   1783
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, ["done right put"]); insert first value into the second; push result (["done right put", 2])
  source code:       print("done right put", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done right put", 2 ]]

================================================
Running thread T1: put_left_test(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=1966 terminated atomic __init__()
  T2: pc=1758 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T3: pc=1784 runnable put_right_test(2)
    about to print [ "done right put", 2 ]
  T4: pc=1787 runnable get_left_test(1)
    about to run method get_left_test with argument 1
  T5: pc=1811 runnable get_right_test(1)
    about to run method get_right_test with argument 1
  T6: pc=1859 runnable peek_right_test(1)
    about to run method peek_right_test with argument 1
shared variables:
  alloc$next: 0
  alloc$pool: {:}
  d: { "count": 1, "data": [ None, [ 2, "rights" ] ], "head": 0, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 }
state id: 13646
================================================

Step 357:
  program counter:   1729
  hvm code:          Frame put_left_test(self)
  explanation:       pop argument (1), assign to self, and run method "put_left_test"
  start statement:   line=12 column=1
  end statement:     line=12 column=24
  source code:       def put_left_test(self):
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 1 }
  call trace:        put_left_test(1)
  stack:             [{:}]

Step 358:
  program counter:   1730
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=13 column=5
  end statement:     line=13 column=32
  source code:       print("call left put", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 359:
  program counter:   1731
  hvm code:          Push "call left put"
  explanation:       push constant "call left put"
  source code:       print("call left put", self)
                           ^^^^^^^^^^^^^^^
  stack:             [{:}, [], "call left put"]

Step 360:
  program counter:   1732
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call left put", []); insert first value into the second; push result (["call left put"])
  source code:       print("call left put", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call left put" ]]

Step 361:
  program counter:   1733
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       print("call left put", self)
                                            ^^^^
  stack:             [{:}, [ "call left put" ], 1]

Step 362:
  program counter:   1734
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, ["call left put"]); insert first value into the second; push result (["call left put", 1])
  source code:       print("call left put", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call left put", 1 ]]

Step 363:
  program counter:   1735
  hvm code:          Print
  explanation:       pop value (["call left put", 1]) and add to print log
  source code:       print("call left put", self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(1)
  stack:             [{:}]

Step 364:
  program counter:   1736
  hvm code:          Push PC(1290)
  explanation:       push program counter constant 1290 ()
  start statement:   line=14 column=5
  end statement:     line=14 column=39
  source code:       bdeque.put_left(?d, (self, "left"))
                     ^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1290)]

Step 365:
  program counter:   1737
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       bdeque.put_left(?d, (self, "left"))
                                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1290), []]

Step 366:
  program counter:   1738
  hvm code:          Push ?d
  explanation:       push constant ?d
  source code:       bdeque.put_left(?d, (self, "left"))
                                      ^
  stack:             [{:}, PC(1290), [], ?d]

Step 367:
  program counter:   1739
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?d, []); insert first value into the second; push result ([?d])
  source code:       bdeque.put_left(?d, (self, "left"))
                                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1290), [ ?d ]]

Step 368:
  program counter:   1740
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       bdeque.put_left(?d, (self, "left"))
                                          ^^^^^^^^^^^^
  stack:             [{:}, PC(1290), [ ?d ], []]

Step 369:
  program counter:   1741
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       bdeque.put_left(?d, (self, "left"))
                                          ^^^^
  stack:             [{:}, PC(1290), [ ?d ], [], 1]

Step 370:
  program counter:   1742
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       bdeque.put_left(?d, (self, "left"))
                                          ^^^^^^^^^^^^
  stack:             [{:}, PC(1290), [ ?d ], [ 1 ]]

Step 371:
  program counter:   1743
  hvm code:          Push "left"
  explanation:       push constant "left"
  source code:       bdeque.put_left(?d, (self, "left"))
                                                ^^^^^^
  stack:             [{:}, PC(1290), [ ?d ], [ 1 ], "left"]

Step 372:
  program counter:   1744
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("left", [1]); insert first value into the second; push result ([1, "left"])
  source code:       bdeque.put_left(?d, (self, "left"))
                                          ^^^^^^^^^^^^
  stack:             [{:}, PC(1290), [ ?d ], [ 1, "left" ]]

Step 373:
  program counter:   1745
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([1, "left"], [?d]); insert first value into the second; push result ([?d, [1, "left"]])
  source code:       bdeque.put_left(?d, (self, "left"))
                                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1290), [ ?d, [ 1, "left" ] ]]

Step 374:
  program counter:   1746
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([?d, [1, "left"]], PC(1290)); push result (?PC(1290)[[?d, [1, "left"]]])
  source code:       bdeque.put_left(?d, (self, "left"))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1290)[[ ?d, [ 1, "left" ] ]]]

Step 375:
  program counter:   1747
  hvm code:          Load
  explanation:       pop an argument ([?d, [1, "left"]]) and call method (1290: "put_left")
  start expression:  line=14 column=5
  end expression:    line=14 column=39
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, [ ?d, [ 1, "left" ] ]]

Step 376:
  program counter:   1290
  hvm code:          Frame put_left(d, v)
  explanation:       pop argument ([?d, [1, "left"]]), assign to (d, v), and run method "put_left"
  module:            bdeque
  start statement:   line=17 column=1
  end statement:     line=17 column=19
  source code:       def put_left(d, v):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d, v: [ 1, "left" ] }
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 377:
  program counter:   1291
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=23 column=5
  end statement:     line=23 column=21
  source code:       acquire(?d->lock)
                              ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d]

Step 378:
  program counter:   1292
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d, "lock"]

Step 379:
  program counter:   1293
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       acquire(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["lock"]]

Step 380:
  program counter:   1294
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?d["lock"]) and call method (954: "acquire")
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"]) --> acquire(?d["lock"])
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, ?d["lock"]]

Step 381:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }]

Step 382:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"]) --> acquire(?d["lock"])

Step 383:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 384:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }, ?d["lock"]]

Step 385:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }, False]

Step 386:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }, True]

Step 387:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }]

Step 388:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 389:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 390:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }, ?d["lock"]]

Step 391:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 392:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }, ?d["lock"], True]

Step 393:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?d["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 1, "data": [ None, [ 2, "rights" ] ], "head": 0, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  stack:             [{:}, [], 27954, { "self": 1 }, [], 20706, { "d": ?d, "v": [ 1, "left" ] }]

Step 394:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 395:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d, v: [ 1, "left" ] }
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, None]

Step 396:
  program counter:   1295
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=23 column=5
  end statement:     line=23 column=21
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 397:
  program counter:   1296
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=24 column=5
  end statement:     line=24 column=30
  source code:       while d->count == d->size:
                           ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d]

Step 398:
  program counter:   1297
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       while d->count == d->size:
                              ^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d, "count"]

Step 399:
  program counter:   1298
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       while d->count == d->size:
                           ^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["count"]]

Step 400:
  program counter:   1299
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (1)
  start expression:  line=24 column=11
  end expression:    line=24 column=18
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, 1]

Step 401:
  program counter:   1300
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       while d->count == d->size:
                                       ^
  stack:             [{:}, [], 27954, { "self": 1 }, 1, ?d]

Step 402:
  program counter:   1301
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       while d->count == d->size:
                                          ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, 1, ?d, "size"]

Step 403:
  program counter:   1302
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("size", ?d); push result (?d["size"])
  source code:       while d->count == d->size:
                                       ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, 1, ?d["size"]]

Step 404:
  program counter:   1303
  hvm code:          Load
  explanation:       pop address (?d["size"]) and push value (2)
  start expression:  line=24 column=23
  end expression:    line=24 column=29
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, 1, 2]

Step 405:
  program counter:   1304
  hvm code:          2-ary ==
  explanation:       pop 2 values (2, 1); check if both values are the same; push result (False)
  source code:       while d->count == d->size:
                           ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, False]

Step 406:
  program counter:   1305
  hvm code:          JumpCond False 1318
  explanation:       pop value (False), compare to False, and jump to 1318 if the same
  source code:       while d->count == d->size:
                     ^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 407:
  program counter:   1318
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=26 column=5
  end statement:     line=26 column=24
  source code:       d->data[d->head] = v 
                     ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d]

Step 408:
  program counter:   1319
  hvm code:          Push "data"
  explanation:       push constant "data"
  source code:       d->data[d->head] = v 
                        ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d, "data"]

Step 409:
  program counter:   1320
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("data", ?d); push result (?d["data"])
  source code:       d->data[d->head] = v 
                     ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["data"]]

Step 410:
  program counter:   1321
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->data[d->head] = v 
                             ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["data"], ?d]

Step 411:
  program counter:   1322
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       d->data[d->head] = v 
                                ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["data"], ?d, "head"]

Step 412:
  program counter:   1323
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       d->data[d->head] = v 
                             ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["data"], ?d["head"]]

Step 413:
  program counter:   1324
  hvm code:          Load
  explanation:       pop address (?d["head"]) and push value (0)
  start expression:  line=26 column=13
  end expression:    line=26 column=19
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["data"], 0]

Step 414:
  program counter:   1325
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?d["data"]); push result (?d["data"][0])
  source code:       d->data[d->head] = v 
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["data"][0]]

Step 415:
  program counter:   1326
  hvm code:          LoadVar v
  explanation:       push value ([1, "left"]) of variable "v"
  source code:       d->data[d->head] = v 
                                        ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["data"][0], [ 1, "left" ]]

Step 416:
  program counter:   1327
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=26 column=24
  end expression:    line=26 column=24
  method variables:  { d: ?d }

Step 417:
  program counter:   1328
  hvm code:          Store
  explanation:       pop value ([1, "left"]) and address (?d["data"][0]) and store
  source code:       d->data[d->head] = v 
                     ^^^^^^^^^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 1, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 0, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 418:
  program counter:   1329
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=27 column=5
  end statement:     line=27 column=37
  source code:       d->head = (d->head - 1) % d->size
                     ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d]

Step 419:
  program counter:   1330
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       d->head = (d->head - 1) % d->size
                        ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d, "head"]

Step 420:
  program counter:   1331
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       d->head = (d->head - 1) % d->size
                     ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"]]

Step 421:
  program counter:   1332
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->head = (d->head - 1) % d->size
                                ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], ?d]

Step 422:
  program counter:   1333
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       d->head = (d->head - 1) % d->size
                                   ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], ?d, "head"]

Step 423:
  program counter:   1334
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       d->head = (d->head - 1) % d->size
                                ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], ?d["head"]]

Step 424:
  program counter:   1335
  hvm code:          Load
  explanation:       pop address (?d["head"]) and push value (0)
  start expression:  line=27 column=16
  end expression:    line=27 column=22
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], 0]

Step 425:
  program counter:   1336
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       d->head = (d->head - 1) % d->size
                                          ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], 0, 1]

Step 426:
  program counter:   1337
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 0); the second integer minus the first; push result (-1)
  source code:       d->head = (d->head - 1) % d->size
                                ^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], -1]

Step 427:
  program counter:   1338
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->head = (d->head - 1) % d->size
                                               ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], -1, ?d]

Step 428:
  program counter:   1339
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       d->head = (d->head - 1) % d->size
                                                  ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], -1, ?d, "size"]

Step 429:
  program counter:   1340
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("size", ?d); push result (?d["size"])
  source code:       d->head = (d->head - 1) % d->size
                                               ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], -1, ?d["size"]]

Step 430:
  program counter:   1341
  hvm code:          Load
  explanation:       pop address (?d["size"]) and push value (2)
  start expression:  line=27 column=31
  end expression:    line=27 column=37
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], -1, 2]

Step 431:
  program counter:   1342
  hvm code:          2-ary %
  explanation:       pop 2 values (2, -1); second value modulo the first; push result (1)
  source code:       d->head = (d->head - 1) % d->size
                               ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["head"], 1]

Step 432:
  program counter:   1343
  hvm code:          Store
  explanation:       pop value (1) and address (?d["head"]) and store
  source code:       d->head = (d->head - 1) % d->size
                     ^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 1, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 433:
  program counter:   1344
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=28 column=5
  end statement:     line=28 column=17
  source code:       d->count += 1
                     ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d]

Step 434:
  program counter:   1345
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       d->count += 1
                        ^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d, "count"]

Step 435:
  program counter:   1346
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       d->count += 1
                     ^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["count"]]

Step 436:
  program counter:   1347
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       d->count += 1
                     ^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["count"], ?d["count"]]

Step 437:
  program counter:   1348
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (1)
  start expression:  line=28 column=5
  end expression:    line=28 column=17
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["count"], 1]

Step 438:
  program counter:   1349
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       d->count += 1
                                 ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["count"], 1, 1]

Step 439:
  program counter:   1350
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 1); add the integers; push result (2)
  source code:       d->count += 1
                     ^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["count"], 2]

Step 440:
  program counter:   1351
  hvm code:          Store
  explanation:       pop value (2) and address (?d["count"]) and store
  source code:       d->count += 1
                     ^^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 2, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 441:
  program counter:   1352
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=30 column=5
  end statement:     line=30 column=21
  source code:       if d->count == 1:
                        ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d]

Step 442:
  program counter:   1353
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       if d->count == 1:
                           ^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d, "count"]

Step 443:
  program counter:   1354
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       if d->count == 1:
                        ^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["count"]]

Step 444:
  program counter:   1355
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (2)
  start expression:  line=30 column=8
  end expression:    line=30 column=15
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, 2]

Step 445:
  program counter:   1356
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       if d->count == 1:
                                    ^
  stack:             [{:}, [], 27954, { "self": 1 }, 2, 1]

Step 446:
  program counter:   1357
  hvm code:          2-ary ==
  explanation:       pop 2 values (1, 2); check if both values are the same; push result (False)
  source code:       if d->count == 1:
                        ^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, False]

Step 447:
  program counter:   1358
  hvm code:          JumpCond False 1364
  explanation:       pop value (False), compare to False, and jump to 1364 if the same
  source code:       if d->count == 1:
                     ^^
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 448:
  program counter:   1364
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=32 column=5
  end statement:     line=32 column=21
  source code:       release(?d->lock)
                              ^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d]

Step 449:
  program counter:   1365
  hvm code:          DelVar d
  explanation:       delete method variable d
  start expression:  line=32 column=14
  end expression:    line=32 column=14
  method variables:  { }

Step 450:
  program counter:   1366
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d, "lock"]

Step 451:
  program counter:   1367
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       release(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, ?d["lock"]]

Step 452:
  program counter:   1368
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?d["lock"]) and call method (973: "release")
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"]) --> release(?d["lock"])
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, ?d["lock"]]

Step 453:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, {:}]

================================================
Running thread T3: put_right_test(2)
mode:  runnable
stack: ['{:}', '[ "done right put", 2 ]']
other threads:
  T0: pc=1966 terminated atomic __init__()
  T1: pc=974 runnable put_left_test(1) --> put_left(?d, [1, "left"]) --> release(?d["lock"])
    about to execute synch:39:     atomically:
  T2: pc=1758 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T4: pc=1787 runnable get_left_test(1)
    about to run method get_left_test with argument 1
  T5: pc=1811 runnable get_right_test(1)
    about to run method get_right_test with argument 1
  T6: pc=1859 runnable peek_right_test(1)
    about to run method peek_right_test with argument 1
shared variables:
  alloc$next: 0
  alloc$pool: {:}
  d: { "count": 2, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 }
state id: 61863
================================================

Step 454:
  program counter:   1784
  hvm code:          Print
  explanation:       pop value (["done right put", 2]) and add to print log
  module:            __main__
  start statement:   line=20 column=5
  end statement:     line=20 column=33
  source code:       print("done right put", self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_right_test(2)
  stack:             [{:}]

Step 455:
  program counter:   1785
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=17 column=1
  end statement:     line=17 column=25
  source code:       def put_right_test(self):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
  new mode:          terminated
  stack:             [None]

================================================
Running thread T1: put_left_test(1) --> put_left(?d, [1, "left"]) --> release(?d["lock"])
method variables:
  binsema: ?d["lock"]
mode:  runnable
stack: ['{:}', '[]', '27954', '{ "self": 1 }', '[]', '21890', '{:}']
other threads:
  T0: pc=1966 terminated atomic __init__()
  T2: pc=1758 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T3: pc=1785 terminated put_right_test(2)
  T4: pc=1787 runnable get_left_test(1)
    about to run method get_left_test with argument 1
  T5: pc=1811 runnable get_right_test(1)
    about to run method get_right_test with argument 1
  T6: pc=1859 runnable peek_right_test(1)
    about to run method peek_right_test with argument 1
shared variables:
  alloc$next: 0
  alloc$pool: {:}
  d: { "count": 2, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 }
state id: 69871
================================================

Step 456:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  module:            synch
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"]) --> release(?d["lock"])

Step 457:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 458:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 459:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, {:}, ?d["lock"]]

Step 460:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, {:}, True]

Step 461:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, {:}]

Step 462:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 463:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 464:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, {:}, ?d["lock"]]

Step 465:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 466:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, {:}, ?d["lock"], False]

Step 467:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?d["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 2, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  stack:             [{:}, [], 27954, { "self": 1 }, [], 21890, {:}]

Step 468:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 469:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(1) --> put_left(?d, [1, "left"])
  stack:             [{:}, [], 27954, { "self": 1 }, None]

Step 470:
  program counter:   1369
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=32 column=5
  end statement:     line=32 column=21
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27954, { "self": 1 }]

Step 471:
  program counter:   1370
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=17 column=1
  end statement:     line=17 column=19
  source code:       def put_left(d, v):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 1 }
  call trace:        put_left_test(1)
  stack:             [{:}, None]

Step 472:
  program counter:   1748
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=14 column=5
  end statement:     line=14 column=39
  source code:       bdeque.put_left(?d, (self, "left"))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 473:
  program counter:   1749
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=15 column=5
  end statement:     line=15 column=32
  source code:       print("done left put", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 474:
  program counter:   1750
  hvm code:          Push "done left put"
  explanation:       push constant "done left put"
  source code:       print("done left put", self)
                           ^^^^^^^^^^^^^^^
  stack:             [{:}, [], "done left put"]

Step 475:
  program counter:   1751
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("done left put", []); insert first value into the second; push result (["done left put"])
  source code:       print("done left put", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done left put" ]]

Step 476:
  program counter:   1752
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       print("done left put", self)
                                            ^^^^
  stack:             [{:}, [ "done left put" ], 1]

Step 477:
  program counter:   1753
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=15 column=28
  end expression:    line=15 column=31
  method variables:  { }

Step 478:
  program counter:   1754
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, ["done left put"]); insert first value into the second; push result (["done left put", 1])
  source code:       print("done left put", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done left put", 1 ]]

================================================
Running thread T5: get_right_test(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=1966 terminated atomic __init__()
  T1: pc=1755 runnable put_left_test(1)
    about to print [ "done left put", 1 ]
  T2: pc=1758 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T3: pc=1785 terminated put_right_test(2)
  T4: pc=1787 runnable get_left_test(1)
    about to run method get_left_test with argument 1
  T6: pc=1859 runnable peek_right_test(1)
    about to run method peek_right_test with argument 1
shared variables:
  alloc$next: 0
  alloc$pool: {:}
  d: { "count": 2, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 }
state id: 80293
================================================

Step 479:
  program counter:   1811
  hvm code:          Frame get_right_test(self)
  explanation:       pop argument (1), assign to self, and run method "get_right_test"
  start statement:   line=27 column=1
  end statement:     line=27 column=25
  source code:       def get_right_test(self):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 1 }
  call trace:        get_right_test(1)
  stack:             [{:}]

Step 480:
  program counter:   1812
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=28 column=5
  end statement:     line=28 column=33
  source code:       print("call right get", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 481:
  program counter:   1813
  hvm code:          Push "call right get"
  explanation:       push constant "call right get"
  source code:       print("call right get", self)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], "call right get"]

Step 482:
  program counter:   1814
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call right get", []); insert first value into the second; push result (["call right get"])
  source code:       print("call right get", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call right get" ]]

Step 483:
  program counter:   1815
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       print("call right get", self)
                                             ^^^^
  stack:             [{:}, [ "call right get" ], 1]

Step 484:
  program counter:   1816
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, ["call right get"]); insert first value into the second; push result (["call right get", 1])
  source code:       print("call right get", self)
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call right get", 1 ]]

Step 485:
  program counter:   1817
  hvm code:          Print
  explanation:       pop value (["call right get", 1]) and add to print log
  source code:       print("call right get", self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        get_right_test(1)
  stack:             [{:}]

Step 486:
  program counter:   1818
  hvm code:          Push PC(1538)
  explanation:       push program counter constant 1538 ()
  start statement:   line=29 column=5
  end statement:     line=29 column=32
  source code:       let v = bdeque.get_right(?d):
                             ^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1538)]

Step 487:
  program counter:   1819
  hvm code:          Push ?d
  explanation:       push constant ?d
  source code:       let v = bdeque.get_right(?d):
                                               ^
  stack:             [{:}, PC(1538), ?d]

Step 488:
  program counter:   1820
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?d, PC(1538)); push result (?PC(1538)[?d])
  source code:       let v = bdeque.get_right(?d):
                             ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1538)[?d]]

Step 489:
  program counter:   1821
  hvm code:          Load
  explanation:       pop an argument (?d) and call method (1538: "get_right")
  start expression:  line=29 column=13
  end expression:    line=29 column=32
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, ?d]

Step 490:
  program counter:   1538
  hvm code:          Frame get_right(d)
  explanation:       pop argument (?d), assign to d, and run method "get_right"
  module:            bdeque
  start statement:   line=68 column=1
  end statement:     line=68 column=31
  source code:       def get_right(d) returns right:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d }
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 491:
  program counter:   1539
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=74 column=5
  end statement:     line=74 column=21
  source code:       acquire(?d->lock)
                              ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 492:
  program counter:   1540
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "lock"]

Step 493:
  program counter:   1541
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       acquire(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["lock"]]

Step 494:
  program counter:   1542
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?d["lock"]) and call method (954: "acquire")
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        get_right_test(1) --> get_right(?d) --> acquire(?d["lock"])
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, ?d["lock"]]

Step 495:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }]

Step 496:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        get_right_test(1) --> get_right(?d) --> acquire(?d["lock"])

Step 497:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 498:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }, ?d["lock"]]

Step 499:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }, False]

Step 500:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }, True]

Step 501:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }]

Step 502:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 503:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 504:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }, ?d["lock"]]

Step 505:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 506:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }, ?d["lock"], True]

Step 507:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?d["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 2, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  stack:             [{:}, [], 29138, { "self": 1 }, [], 24674, { "d": ?d }]

Step 508:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 509:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d }
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, None]

Step 510:
  program counter:   1543
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=74 column=5
  end statement:     line=74 column=21
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 511:
  program counter:   1544
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=75 column=5
  end statement:     line=75 column=24
  source code:       while d->count == 0:
                           ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 512:
  program counter:   1545
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       while d->count == 0:
                              ^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "count"]

Step 513:
  program counter:   1546
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       while d->count == 0:
                           ^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["count"]]

Step 514:
  program counter:   1547
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (2)
  start expression:  line=75 column=11
  end expression:    line=75 column=18
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, 2]

Step 515:
  program counter:   1548
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while d->count == 0:
                                       ^
  stack:             [{:}, [], 29138, { "self": 1 }, 2, 0]

Step 516:
  program counter:   1549
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 2); check if both values are the same; push result (False)
  source code:       while d->count == 0:
                           ^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, False]

Step 517:
  program counter:   1550
  hvm code:          JumpCond False 1563
  explanation:       pop value (False), compare to False, and jump to 1563 if the same
  source code:       while d->count == 0:
                     ^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 518:
  program counter:   1563
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=77 column=5
  end statement:     line=77 column=37
  source code:       d->tail = (d->head - 1) % d->size
                     ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 519:
  program counter:   1564
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       d->tail = (d->head - 1) % d->size
                        ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "tail"]

Step 520:
  program counter:   1565
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("tail", ?d); push result (?d["tail"])
  source code:       d->tail = (d->head - 1) % d->size
                     ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"]]

Step 521:
  program counter:   1566
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->tail = (d->head - 1) % d->size
                                ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], ?d]

Step 522:
  program counter:   1567
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       d->tail = (d->head - 1) % d->size
                                   ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], ?d, "head"]

Step 523:
  program counter:   1568
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       d->tail = (d->head - 1) % d->size
                                ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], ?d["head"]]

Step 524:
  program counter:   1569
  hvm code:          Load
  explanation:       pop address (?d["head"]) and push value (1)
  start expression:  line=77 column=16
  end expression:    line=77 column=22
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 1]

Step 525:
  program counter:   1570
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       d->tail = (d->head - 1) % d->size
                                          ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 1, 1]

Step 526:
  program counter:   1571
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       d->tail = (d->head - 1) % d->size
                                ^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 0]

Step 527:
  program counter:   1572
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->tail = (d->head - 1) % d->size
                                               ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 0, ?d]

Step 528:
  program counter:   1573
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       d->tail = (d->head - 1) % d->size
                                                  ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 0, ?d, "size"]

Step 529:
  program counter:   1574
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("size", ?d); push result (?d["size"])
  source code:       d->tail = (d->head - 1) % d->size
                                               ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 0, ?d["size"]]

Step 530:
  program counter:   1575
  hvm code:          Load
  explanation:       pop address (?d["size"]) and push value (2)
  start expression:  line=77 column=31
  end expression:    line=77 column=37
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 0, 2]

Step 531:
  program counter:   1576
  hvm code:          2-ary %
  explanation:       pop 2 values (2, 0); second value modulo the first; push result (0)
  source code:       d->tail = (d->head - 1) % d->size
                               ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["tail"], 0]

Step 532:
  program counter:   1577
  hvm code:          Store
  explanation:       pop value (0) and address (?d["tail"]) and store
  source code:       d->tail = (d->head - 1) % d->size
                     ^^^^^^^^^
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 533:
  program counter:   1578
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=78 column=5
  end statement:     line=78 column=28
  source code:       right = d->data[d->tail]
                             ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 534:
  program counter:   1579
  hvm code:          Push "data"
  explanation:       push constant "data"
  source code:       right = d->data[d->tail]
                                ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "data"]

Step 535:
  program counter:   1580
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("data", ?d); push result (?d["data"])
  source code:       right = d->data[d->tail]
                             ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["data"]]

Step 536:
  program counter:   1581
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       right = d->data[d->tail]
                                     ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["data"], ?d]

Step 537:
  program counter:   1582
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       right = d->data[d->tail]
                                        ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["data"], ?d, "tail"]

Step 538:
  program counter:   1583
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("tail", ?d); push result (?d["tail"])
  source code:       right = d->data[d->tail]
                                     ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["data"], ?d["tail"]]

Step 539:
  program counter:   1584
  hvm code:          Load
  explanation:       pop address (?d["tail"]) and push value (0)
  start expression:  line=78 column=21
  end expression:    line=78 column=27
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["data"], 0]

Step 540:
  program counter:   1585
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?d["data"]); push result (?d["data"][0])
  source code:       right = d->data[d->tail]
                             ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["data"][0]]

Step 541:
  program counter:   1586
  hvm code:          Load
  explanation:       pop address (?d["data"][0]) and push value ([1, "left"])
  start expression:  line=78 column=13
  end expression:    line=78 column=28
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, [ 1, "left" ]]

Step 542:
  program counter:   1587
  hvm code:          StoreVar right
  explanation:       pop value ([1, "left"]) and store locally in variable \"right\"
  source code:       right = d->data[d->tail]
                     ^^^^^^^
  method variables:  { d: ?d, right: [ 1, "left" ] }
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 543:
  program counter:   1588
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=79 column=5
  end statement:     line=79 column=17
  source code:       d->count -= 1
                     ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 544:
  program counter:   1589
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       d->count -= 1
                        ^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "count"]

Step 545:
  program counter:   1590
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       d->count -= 1
                     ^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["count"]]

Step 546:
  program counter:   1591
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       d->count -= 1
                     ^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["count"], ?d["count"]]

Step 547:
  program counter:   1592
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (2)
  start expression:  line=79 column=5
  end expression:    line=79 column=17
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["count"], 2]

Step 548:
  program counter:   1593
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       d->count -= 1
                                 ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["count"], 2, 1]

Step 549:
  program counter:   1594
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 2); the second integer minus the first; push result (1)
  source code:       d->count -= 1
                     ^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["count"], 1]

Step 550:
  program counter:   1595
  hvm code:          Store
  explanation:       pop value (1) and address (?d["count"]) and store
  source code:       d->count -= 1
                     ^^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 1, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": True, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 551:
  program counter:   1596
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=81 column=5
  end statement:     line=81 column=33
  source code:       if d->count == (d->size - 1):
                        ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 552:
  program counter:   1597
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       if d->count == (d->size - 1):
                           ^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "count"]

Step 553:
  program counter:   1598
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("count", ?d); push result (?d["count"])
  source code:       if d->count == (d->size - 1):
                        ^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["count"]]

Step 554:
  program counter:   1599
  hvm code:          Load
  explanation:       pop address (?d["count"]) and push value (1)
  start expression:  line=81 column=8
  end expression:    line=81 column=15
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, 1]

Step 555:
  program counter:   1600
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       if d->count == (d->size - 1):
                                     ^
  stack:             [{:}, [], 29138, { "self": 1 }, 1, ?d]

Step 556:
  program counter:   1601
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       if d->count == (d->size - 1):
                                        ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, 1, ?d, "size"]

Step 557:
  program counter:   1602
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("size", ?d); push result (?d["size"])
  source code:       if d->count == (d->size - 1):
                                     ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, 1, ?d["size"]]

Step 558:
  program counter:   1603
  hvm code:          Load
  explanation:       pop address (?d["size"]) and push value (2)
  start expression:  line=81 column=21
  end expression:    line=81 column=27
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, 1, 2]

Step 559:
  program counter:   1604
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       if d->count == (d->size - 1):
                                               ^
  stack:             [{:}, [], 29138, { "self": 1 }, 1, 2, 1]

Step 560:
  program counter:   1605
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 2); the second integer minus the first; push result (1)
  source code:       if d->count == (d->size - 1):
                                     ^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, 1, 1]

Step 561:
  program counter:   1606
  hvm code:          2-ary ==
  explanation:       pop 2 values (1, 1); check if both values are the same; push result (True)
  source code:       if d->count == (d->size - 1):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, True]

Step 562:
  program counter:   1607
  hvm code:          JumpCond False 1613
  explanation:       pop value (True), compare to False, and jump to 1613 if the same
  source code:       if d->count == (d->size - 1):
                     ^^
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 563:
  program counter:   1608
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=82 column=9
  end statement:     line=82 column=31
  source code:       notifyAll(?d->not_full) 
                                ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 564:
  program counter:   1609
  hvm code:          Push "not_full"
  explanation:       push constant "not_full"
  source code:       notifyAll(?d->not_full) 
                                   ^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "not_full"]

Step 565:
  program counter:   1610
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("not_full", ?d); push result (?d["not_full"])
  source code:       notifyAll(?d->not_full) 
                                ^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["not_full"]]

Step 566:
  program counter:   1611
  hvm code:          Apply PC(1097)
  explanation:       pop an argument (?d["not_full"]) and call method (1097: "notifyAll")
  source code:       notifyAll(?d->not_full) 
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        get_right_test(1) --> get_right(?d) --> notifyAll(?d["not_full"])
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, ?d["not_full"]]

Step 567:
  program counter:   1097
  hvm code:          Frame notifyAll(c)
  explanation:       pop argument (?d["not_full"]), assign to c, and run method "notifyAll"
  module:            synch
  start statement:   line=60 column=1
  end statement:     line=60 column=17
  source code:       def notifyAll(c):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { c: ?d["not_full"] }
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }]

Step 568:
  program counter:   1098
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=61 column=16
  end statement:     line=61 column=31
  source code:       atomically !c = bag.empty()
                                ^^^^^^^^^^^^^^^^
  call trace:        get_right_test(1) --> get_right(?d) --> notifyAll(?d["not_full"])

Step 569:
  program counter:   1099
  hvm code:          LoadVar c
  explanation:       push value (?d["not_full"]) of variable "c"
  source code:       atomically !c = bag.empty()
                                 ^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"]]

Step 570:
  program counter:   1100
  hvm code:          DelVar c
  explanation:       delete method variable c
  start expression:  line=61 column=17
  end expression:    line=61 column=17
  method variables:  { }

Step 571:
  program counter:   1101
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically !c = bag.empty()
                                     ^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], PC(541)]

Step 572:
  program counter:   1102
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically !c = bag.empty()
                                              ^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], PC(541), []]

Step 573:
  program counter:   1103
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically !c = bag.empty()
                                     ^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], ?PC(541)[[]]]

Step 574:
  program counter:   1104
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=61 column=21
  end expression:    line=61 column=31
  call trace:        get_right_test(1) --> get_right(?d) --> notifyAll(?d["not_full"]) --> empty()
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], [], 17666, []]

Step 575:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], [], 17666, {:}]

Step 576:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], [], 17666, {:}, {:}]

Step 577:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], [], 17666, {:}]

Step 578:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        get_right_test(1) --> get_right(?d) --> notifyAll(?d["not_full"])
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }, ?d["not_full"], {:}]

Step 579:
  program counter:   1105
  hvm code:          Store
  explanation:       pop value ({:}) and address (?d["not_full"]) and store
  module:            synch
  start statement:   line=61 column=16
  end statement:     line=61 column=31
  source code:       atomically !c = bag.empty()
                                ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25778, { "d": ?d, "right": [ 1, "left" ] }]

Step 580:
  program counter:   1106
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  source code:       atomically !c = bag.empty()
                                ^^^^^^^^^^^^^^^^

Step 581:
  program counter:   1107
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=60 column=1
  end statement:     line=60 column=17
  source code:       def notifyAll(c):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d, right: [ 1, "left" ] }
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, None]

Step 582:
  program counter:   1612
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=82 column=9
  end statement:     line=82 column=31
  source code:       notifyAll(?d->not_full) 
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 583:
  program counter:   1613
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=83 column=5
  end statement:     line=83 column=21
  source code:       release(?d->lock)
                              ^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d]

Step 584:
  program counter:   1614
  hvm code:          DelVar d
  explanation:       delete method variable d
  start expression:  line=83 column=14
  end expression:    line=83 column=14
  method variables:  { right: [ 1, "left" ] }

Step 585:
  program counter:   1615
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d, "lock"]

Step 586:
  program counter:   1616
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       release(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, ?d["lock"]]

Step 587:
  program counter:   1617
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?d["lock"]) and call method (973: "release")
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        get_right_test(1) --> get_right(?d) --> release(?d["lock"])
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, ?d["lock"]]

Step 588:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, { "right": [ 1, "left" ] }]

Step 589:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        get_right_test(1) --> get_right(?d) --> release(?d["lock"])

Step 590:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 591:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 592:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, { "right": [ 1, "left" ] }, ?d["lock"]]

Step 593:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, { "right": [ 1, "left" ] }, True]

Step 594:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, { "right": [ 1, "left" ] }]

Step 595:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 596:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 597:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, { "right": [ 1, "left" ] }, ?d["lock"]]

Step 598:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 599:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, { "right": [ 1, "left" ] }, ?d["lock"], False]

Step 600:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?d["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "count": 1, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 } }
  stack:             [{:}, [], 29138, { "self": 1 }, [], 25874, { "right": [ 1, "left" ] }]

Step 601:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 602:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { right: [ 1, "left" ] }
  call trace:        get_right_test(1) --> get_right(?d)
  stack:             [{:}, [], 29138, { "self": 1 }, None]

Step 603:
  program counter:   1618
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            bdeque
  start statement:   line=83 column=5
  end statement:     line=83 column=21
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 29138, { "self": 1 }]

Step 604:
  program counter:   1619
  hvm code:          ReturnOp(right)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=68 column=1
  end statement:     line=68 column=31
  source code:       def get_right(d) returns right:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 1 }
  call trace:        get_right_test(1)
  stack:             [{:}, [ 1, "left" ]]

Step 605:
  program counter:   1822
  hvm code:          StoreVar v
  explanation:       pop value ([1, "left"]) and store locally in variable \"v\"
  module:            __main__
  start statement:   line=29 column=5
  end statement:     line=29 column=32
  source code:       let v = bdeque.get_right(?d):
                     ^^^^^^^
  method variables:  { self: 1, v: [ 1, "left" ] }
  stack:             [{:}]

Step 606:
  program counter:   1823
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=30 column=9
  end statement:     line=30 column=40
  source code:       print("done right get", self, v)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 607:
  program counter:   1824
  hvm code:          Push "done right get"
  explanation:       push constant "done right get"
  source code:       print("done right get", self, v)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], "done right get"]

Step 608:
  program counter:   1825
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("done right get", []); insert first value into the second; push result (["done right get"])
  source code:       print("done right get", self, v)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done right get" ]]

Step 609:
  program counter:   1826
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       print("done right get", self, v)
                                             ^^^^
  stack:             [{:}, [ "done right get" ], 1]

Step 610:
  program counter:   1827
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=30 column=33
  end expression:    line=30 column=36
  method variables:  { v: [ 1, "left" ] }

Step 611:
  program counter:   1828
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, ["done right get"]); insert first value into the second; push result (["done right get", 1])
  source code:       print("done right get", self, v)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done right get", 1 ]]

Step 612:
  program counter:   1829
  hvm code:          LoadVar v
  explanation:       push value ([1, "left"]) of variable "v"
  source code:       print("done right get", self, v)
                                                   ^
  stack:             [{:}, [ "done right get", 1 ], [ 1, "left" ]]

Step 613:
  program counter:   1830
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=30 column=39
  end expression:    line=30 column=39
  method variables:  { }

Step 614:
  program counter:   1831
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([1, "left"], ["done right get", 1]); insert first value into the second; push result (["done right get", 1, [1, "left"]])
  source code:       print("done right get", self, v)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done right get", 1, [ 1, "left" ] ]]

Step 615:
  program counter:   1832
  hvm code:          Print
  explanation:       pop value (["done right get", 1, [1, "left"]]) and add to print log
  source code:       print("done right get", self, v)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        get_right_test(1)
  new mode:          failed
  stack:             [{:}]
  operation failed:  Behavior failure on ["done right get", 1, [1, "left"]]

================================================
Final state
================================================
Threads:
  T0: pc=1966 terminated atomic __init__()
  T1: pc=1755 runnable put_left_test(1)
    about to print [ "done left put", 1 ]
  T2: pc=1758 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T3: pc=1785 terminated put_right_test(2)
  T4: pc=1787 runnable get_left_test(1)
    about to run method get_left_test with argument 1
  T5: pc=1832 failed get_right_test(1)
  T6: pc=1859 runnable peek_right_test(1)
    about to run method peek_right_test with argument 1
Variables:
  alloc$next: 0
  alloc$pool: {:}
  d: { "count": 1, "data": [ [ 1, "left" ], [ 2, "rights" ] ], "head": 1, "lock": False, "not_empty": {:}, "not_full": {:}, "size": 2, "tail": 0 }
